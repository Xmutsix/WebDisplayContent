<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Geometry Dash</title>
    
    <!-- ПОДКЛЮЧАЕМ МУЗЫКУ -->
    <script src="music.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        
        body {
            background: #0a0a1a;
            overflow: hidden;
        }
        
        #game {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 26, 0.95);
            text-align: center;
            padding-top: 80px;
        }
        
        .hidden {
            display: none;
        }
        
        h1 {
            font-family: Arial, sans-serif;
            font-size: 48px;
            color: #00d4ff;
            margin-bottom: 10px;
        }
        
        .subtitle {
            color: #888;
            font-family: Arial, sans-serif;
            font-size: 16px;
            margin-bottom: 30px;
        }
        
        .btn {
            font-family: Arial, sans-serif;
            font-size: 20px;
            padding: 15px 50px;
            margin: 10px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            color: white;
        }
        
        .btn-play {
            background: #00a8cc;
        }
        
        .btn-retry {
            background: #e74c3c;
        }
        
        .btn-menu {
            background: #9b59b6;
        }
        
        .btn-hub {
            background: #565f89;
        }
        
        .game-over-title {
            font-family: Arial, sans-serif;
            font-size: 52px;
            color: #e74c3c;
            margin-bottom: 10px;
        }
        
        .score-display {
            font-family: Arial, sans-serif;
            font-size: 28px;
            color: #fff;
            margin-bottom: 10px;
        }
        
        .best-score {
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: #f1c40f;
            margin-bottom: 30px;
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            font-family: Arial, sans-serif;
            font-size: 18px;
            color: white;
        }
        
        #modeIndicator {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 10px;
            font-size: 14px;
            margin-top: 5px;
            background: #00d4ff;
        }
        
        #musicStatus {
            position: absolute;
            top: 10px;
            right: 10px;
            font-family: Arial, sans-serif;
            font-size: 12px;
            color: #666;
        }
        
        .instructions {
            color: #666;
            font-family: Arial, sans-serif;
            font-size: 14px;
            margin-top: 30px;
            line-height: 1.8;
        }
        
        /* НАВИГАЦИЯ - КНОПКА ВОЗВРАТА В ХАБ */
        .back-link {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 200;
            color: rgba(255,255,255,0.4);
            text-decoration: none;
            font-family: Arial, sans-serif;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 8px 20px;
            border-radius: 20px;
            transition: 0.3s;
        }
        .back-link:hover {
            color: #fff;
            border-color: #00d4ff;
            background: rgba(0,212,255,0.1);
        }
    </style>
</head>
<body>
    
    <!-- НАВИГАЦИЯ -->
    <a href="index.html" class="back-link">← BACK TO APP'S</a>
    
    <canvas id="game"></canvas>
    
    <div id="hud" class="hidden">
        <div>Score: <span id="scoreText">0</span></div>
        <div id="modeIndicator">CUBE</div>
    </div>
    
    <div id="musicStatus">Music: loading...</div>
    
    <div id="menuScreen" class="overlay">
        <h1>GEOMETRY DASH</h1>
        <p class="subtitle">Click anywhere to control!</p>
        <br><br>
        <button class="btn btn-play" id="btnPlay">PLAY</button>
        <p class="instructions">
            CUBE: Click to jump<br>
            SHIP: Click to toggle up/down<br>
            UFO: Click for boost<br>
            WAVE: Click to switch direction
        </p>
    </div>
    
    <div id="gameOverScreen" class="overlay hidden">
        <div class="game-over-title">GAME OVER</div>
        <div class="score-display">Score: <span id="finalScore">0</span></div>
        <div class="best-score">Best: <span id="bestScore">0</span></div>
        <br>
        <button class="btn btn-retry" id="btnRetry">RETRY</button>
        <br>
        <button class="btn btn-hub" onclick="location.href='index.html'">EXIT TO HUB</button>
    </div>

    <script>
    // ============ POLYFILLS ============
    var requestAnimFrame = (function() {
        return window.requestAnimationFrame ||
               window.webkitRequestAnimationFrame ||
               window.mozRequestAnimationFrame ||
               function(callback) {
                   window.setTimeout(callback, 1000 / 60);
               };
    })();
    
    var storage = {
        get: function(key) {
            try { return localStorage.getItem(key); } catch(e) { return null; }
        },
        set: function(key, val) {
            try { localStorage.setItem(key, val); } catch(e) {}
        }
    };
    
    // ============ MUSIC SYSTEM ============
    var bgMusic = null;
    var musicReady = false;
    var musicStatusEl = document.getElementById('musicStatus');
    
    function initMusic() {
        if (typeof myAudioData === 'undefined') {
            musicStatusEl.innerHTML = 'Music: not found';
            musicStatusEl.style.color = '#e74c3c';
            return;
        }
        
        try {
            bgMusic = new Audio();
            
            bgMusic.oncanplaythrough = function() {
                musicReady = true;
                musicStatusEl.innerHTML = 'Music: ready';
                musicStatusEl.style.color = '#00ff88';
            };
            
            bgMusic.onerror = function(e) {
                musicReady = false;
                musicStatusEl.innerHTML = 'Music: error';
                musicStatusEl.style.color = '#e74c3c';
            };
            
            bgMusic.onplay = function() {
                musicStatusEl.innerHTML = 'Music: playing';
                musicStatusEl.style.color = '#00d4ff';
            };
            
            bgMusic.onpause = function() {
                if (musicReady) {
                    musicStatusEl.innerHTML = 'Music: paused';
                    musicStatusEl.style.color = '#f1c40f';
                }
            };
            
            bgMusic.src = myAudioData;
            bgMusic.loop = true;
            bgMusic.volume = 0.5;
            bgMusic.load();
            
            musicStatusEl.innerHTML = 'Music: loading...';
            musicStatusEl.style.color = '#f1c40f';
            
        } catch(e) {
            bgMusic = null;
            musicReady = false;
            musicStatusEl.innerHTML = 'Music: failed';
            musicStatusEl.style.color = '#e74c3c';
        }
    }
    
    function playMusic() {
        if (bgMusic && musicReady) {
            try {
                bgMusic.currentTime = 0;
                bgMusic.play();
            } catch(e) {}
        }
    }
    
    function stopMusic() {
        if (bgMusic) {
            try {
                bgMusic.pause();
                bgMusic.currentTime = 0;
            } catch(e) {}
        }
    }
    
    initMusic();
    
    // ============ CANVAS SETUP ============
    var canvas = document.getElementById('game');
    var ctx = canvas.getContext('2d');
    
    function resizeCanvas() {
        canvas.width = window.innerWidth || 800;
        canvas.height = window.innerHeight || 500;
    }
    resizeCanvas();
    
    if (window.addEventListener) {
        window.addEventListener('resize', resizeCanvas, false);
    }
    
    // ============ CONFIGURATION ============
    var CONFIG = {
        GAME_SPEED: 300,
        GRAVITY: 2000,
        CUBE_JUMP: 650,
        SHIP_UP_FORCE: 900,
        SHIP_DOWN_FORCE: 900,
        UFO_BOOST: 480,
        WAVE_SPEED: 500,
        GROUND_HEIGHT: 70,
        PLAYER_SIZE: 34,
        MIN_GAP: 200,
        MAX_GAP: 380,
        PORTAL_CHANCE: 0.12
    };
    
    // ============ GAME STATE ============
    var gamePhase = 'menu';
    var score = 0;
    var bestScore = parseInt(storage.get('gd_best')) || 0;
    var distance = 0;
    var nextSpawnX = 600;
    var portalCooldown = 0;
    
    // ============ PLAYER ============
    var player = {
        x: 100,
        y: 0,
        vy: 0,
        rotation: 0,
        mode: 'cube',
        grounded: false,
        flyingUp: false
    };
    
    // ============ OBJECT POOLS ============
    var obstacles = [];
    var portals = [];
    var particles = [];
    
    var MAX_OBSTACLES = 20;
    var MAX_PORTALS = 6;
    var MAX_PARTICLES = 60;
    
    // ============ INPUT STATE ============
    var inputJustPressed = false;
    
    // ============ DOM ELEMENTS ============
    var hudEl = document.getElementById('hud');
    var scoreTextEl = document.getElementById('scoreText');
    var modeIndicatorEl = document.getElementById('modeIndicator');
    var menuScreenEl = document.getElementById('menuScreen');
    var gameOverScreenEl = document.getElementById('gameOverScreen');
    var finalScoreEl = document.getElementById('finalScore');
    var bestScoreEl = document.getElementById('bestScore');
    
    // ============ INITIALIZATION ============
    function initPools() {
        var i;
        obstacles = [];
        portals = [];
        particles = [];
        
        for (i = 0; i < MAX_OBSTACLES; i++) {
            obstacles.push({
                active: false, x: 0, y: 0, w: 0, h: 0, type: '', rotation: 0
            });
        }
        
        for (i = 0; i < MAX_PORTALS; i++) {
            portals.push({
                active: false, x: 0, targetMode: '', animPhase: 0
            });
        }
        
        for (i = 0; i < MAX_PARTICLES; i++) {
            particles.push({
                active: false, x: 0, y: 0, vx: 0, vy: 0, life: 0, maxLife: 0, color: '', size: 0
            });
        }
    }
    
    function getInactiveFromPool(pool) {
        for (var i = 0; i < pool.length; i++) {
            if (!pool[i].active) return pool[i];
        }
        return null;
    }
    
    function resetGame() {
        gamePhase = 'playing';
        score = 0;
        distance = 0;
        nextSpawnX = 600;
        portalCooldown = 0;
        
        var groundY = canvas.height - CONFIG.GROUND_HEIGHT;
        player.x = 100;
        player.y = groundY - CONFIG.PLAYER_SIZE;
        player.vy = 0;
        player.rotation = 0;
        player.mode = 'cube';
        player.grounded = true;
        player.flyingUp = false;
        
        initPools();
        
        hudEl.className = '';
        menuScreenEl.className = 'overlay hidden';
        gameOverScreenEl.className = 'overlay hidden';
        updateModeIndicator();
        
        playMusic();
    }
    
    function showMenu() {
        gamePhase = 'menu';
        hudEl.className = 'hidden';
        menuScreenEl.className = 'overlay';
        gameOverScreenEl.className = 'overlay hidden';
        stopMusic();
    }
    
    function showGameOver() {
        gamePhase = 'dead';
        stopMusic();
        
        if (score > bestScore) {
            bestScore = score;
            storage.set('gd_best', bestScore);
        }
        
        finalScoreEl.innerHTML = score;
        bestScoreEl.innerHTML = bestScore;
        gameOverScreenEl.className = 'overlay';
        
        spawnParticleBurst(
            player.x + CONFIG.PLAYER_SIZE / 2,
            player.y + CONFIG.PLAYER_SIZE / 2,
            '#e74c3c', 20
        );
    }
    
    function updateModeIndicator() {
        var colors = {
            cube: '#00d4ff',
            ship: '#e056fd',
            ufo: '#00ff88',
            wave: '#f1c40f'
        };
        modeIndicatorEl.innerHTML = player.mode.toUpperCase();
        modeIndicatorEl.style.background = colors[player.mode] || '#00d4ff';
    }
    
    // ============ SPAWNING ============
    function spawnObstacle() {
        var obj = getInactiveFromPool(obstacles);
        if (!obj) return;
        
        var groundY = canvas.height - CONFIG.GROUND_HEIGHT;
        var types = ['spike', 'spike', 'spike', 'block', 'tall_spike', 'double_spike', 'saw'];
        var type = types[Math.floor(Math.random() * types.length)];
        
        obj.active = true;
        obj.x = nextSpawnX;
        obj.type = type;
        obj.rotation = 0;
        
        if (type === 'spike') {
            obj.w = 38; obj.h = 38;
            obj.y = groundY - 38;
        } else if (type === 'tall_spike') {
            obj.w = 38; obj.h = 65;
            obj.y = groundY - 65;
        } else if (type === 'double_spike') {
            obj.w = 76; obj.h = 38;
            obj.y = groundY - 38;
        } else if (type === 'block') {
            obj.w = 38; obj.h = 38;
            obj.y = groundY - 38;
        } else if (type === 'saw') {
            obj.w = 46; obj.h = 46;
            obj.y = groundY - 46;
        }
        
        if (player.mode !== 'cube' && Math.random() > 0.5) {
            obj.y = 60 + Math.random() * (groundY - 180);
        }
        
        nextSpawnX += CONFIG.MIN_GAP + Math.random() * (CONFIG.MAX_GAP - CONFIG.MIN_GAP);
    }
    
    function spawnPortal() {
        if (portalCooldown > 0) return;
        if (Math.random() > CONFIG.PORTAL_CHANCE) return;
        
        var obj = getInactiveFromPool(portals);
        if (!obj) return;
        
        var modes = ['cube', 'ship', 'ufo', 'wave'];
        var available = [];
        for (var i = 0; i < modes.length; i++) {
            if (modes[i] !== player.mode) available.push(modes[i]);
        }
        
        obj.active = true;
        obj.x = nextSpawnX - 100;
        obj.targetMode = available[Math.floor(Math.random() * available.length)];
        obj.animPhase = 0;
        
        portalCooldown = 900;
    }
    
    function spawnParticle(x, y, vx, vy, color, life, size) {
        var p = getInactiveFromPool(particles);
        if (!p) return;
        
        p.active = true;
        p.x = x; p.y = y;
        p.vx = vx; p.vy = vy;
        p.color = color;
        p.life = life; p.maxLife = life;
        p.size = size || 4;
    }
    
    function spawnParticleBurst(x, y, color, count) {
        for (var i = 0; i < count; i++) {
            var angle = Math.random() * Math.PI * 2;
            var speed = 80 + Math.random() * 250;
            spawnParticle(x, y, Math.cos(angle) * speed, Math.sin(angle) * speed, color, 0.4 + Math.random() * 0.4, 3 + Math.random() * 4);
        }
    }
    
    // ============ PHYSICS ============
    function updatePlayer(dt) {
        var groundY = canvas.height - CONFIG.GROUND_HEIGHT;
        var ceiling = 15;
        
        if (inputJustPressed) {
            if (player.mode === 'ship' || player.mode === 'wave') {
                player.flyingUp = !player.flyingUp;
                
                var colors = { ship: '#e056fd', wave: '#f1c40f' };
                spawnParticleBurst(
                    player.x + CONFIG.PLAYER_SIZE / 2,
                    player.y + CONFIG.PLAYER_SIZE / 2,
                    colors[player.mode], 5
                );
            }
        }
        
        if (player.mode === 'cube') {
            player.vy += CONFIG.GRAVITY * dt;
            player.y += player.vy * dt;
            
            if (player.y >= groundY - CONFIG.PLAYER_SIZE) {
                player.y = groundY - CONFIG.PLAYER_SIZE;
                player.vy = 0;
                player.grounded = true;
                player.rotation = Math.round(player.rotation / 90) * 90;
            } else {
                player.grounded = false;
                player.rotation += 360 * dt;
            }
            
            if (inputJustPressed && player.grounded) {
                player.vy = -CONFIG.CUBE_JUMP;
                player.grounded = false;
            }
            
        } else if (player.mode === 'ship') {
            if (player.flyingUp) {
                player.vy -= CONFIG.SHIP_UP_FORCE * dt;
            } else {
                player.vy += CONFIG.SHIP_DOWN_FORCE * dt;
            }
            
            if (player.vy < -400) player.vy = -400;
            if (player.vy > 400) player.vy = 400;
            
            player.y += player.vy * dt;
            player.rotation = player.vy * 0.04;
            
            if (Math.random() > 0.6) {
                spawnParticle(player.x, player.y + CONFIG.PLAYER_SIZE / 2, -80, (Math.random() - 0.5) * 40, '#e056fd', 0.25, 3);
            }
            
        } else if (player.mode === 'ufo') {
            if (inputJustPressed) {
                player.vy = -CONFIG.UFO_BOOST;
            }
            
            player.vy += CONFIG.GRAVITY * 0.35 * dt;
            player.y += player.vy * dt;
            player.rotation = 0;
            
        } else if (player.mode === 'wave') {
            if (player.flyingUp) {
                player.vy = -CONFIG.WAVE_SPEED;
            } else {
                player.vy = CONFIG.WAVE_SPEED;
            }
            
            player.y += player.vy * dt;
            player.rotation = player.vy > 0 ? 45 : -45;
            
            spawnParticle(player.x, player.y + CONFIG.PLAYER_SIZE / 2, -60, 0, '#f1c40f', 0.3, 3);
        }
        
        if (player.y < ceiling) {
            player.y = ceiling;
            if (player.vy < 0) player.vy = 0;
            if (player.mode === 'wave') player.flyingUp = false;
        }
        if (player.y > groundY - CONFIG.PLAYER_SIZE) {
            player.y = groundY - CONFIG.PLAYER_SIZE;
            player.vy = 0;
            if (player.mode === 'wave') player.flyingUp = true;
        }
    }
    
    function updateObstacles(dt) {
        var scrollDelta = CONFIG.GAME_SPEED * dt;
        
        for (var i = 0; i < obstacles.length; i++) {
            var obj = obstacles[i];
            if (!obj.active) continue;
            
            obj.x -= scrollDelta;
            
            if (obj.type === 'saw') {
                obj.rotation += 300 * dt;
            }
            
            if (obj.x < -100) {
                obj.active = false;
                continue;
            }
            
            if (checkCollision(obj)) {
                showGameOver();
                return;
            }
        }
    }
    
    function updatePortals(dt) {
        var scrollDelta = CONFIG.GAME_SPEED * dt;
        var groundY = canvas.height - CONFIG.GROUND_HEIGHT;
        
        for (var i = 0; i < portals.length; i++) {
            var obj = portals[i];
            if (!obj.active) continue;
            
            obj.x -= scrollDelta;
            obj.animPhase += dt * 3;
            
            if (obj.x < -80) {
                obj.active = false;
                continue;
            }
            
            var portalW = 50;
            
            if (player.x + CONFIG.PLAYER_SIZE > obj.x && player.x < obj.x + portalW) {
                player.mode = obj.targetMode;
                player.flyingUp = false;
                
                updateModeIndicator();
                
                var colors = { cube: '#00d4ff', ship: '#e056fd', ufo: '#00ff88', wave: '#f1c40f' };
                spawnParticleBurst(player.x + CONFIG.PLAYER_SIZE / 2, player.y + CONFIG.PLAYER_SIZE / 2, colors[obj.targetMode], 15);
                
                obj.active = false;
            }
        }
        
        if (portalCooldown > 0) {
            portalCooldown -= scrollDelta;
        }
    }
    
    function updateParticles(dt) {
        for (var i = 0; i < particles.length; i++) {
            var p = particles[i];
            if (!p.active) continue;
            
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy += 400 * dt;
            p.life -= dt;
            
            if (p.life <= 0) p.active = false;
        }
    }
    
    function checkCollision(obj) {
        var px = player.x + 5;
        var py = player.y + 5;
        var pw = CONFIG.PLAYER_SIZE - 10;
        var ph = CONFIG.PLAYER_SIZE - 10;
        
        if (!(px < obj.x + obj.w && px + pw > obj.x && py < obj.y + obj.h && py + ph > obj.y)) {
            return false;
        }
        
        if (obj.type === 'spike' || obj.type === 'tall_spike') {
            var cx = px + pw / 2;
            var cy = py + ph / 2;
            var tipX = obj.x + obj.w / 2;
            var tipY = obj.y;
            var baseY = obj.y + obj.h;
            
            if (cy > tipY && cy < baseY) {
                var ratio = (cy - tipY) / obj.h;
                var halfWidth = (obj.w / 2) * ratio;
                if (Math.abs(cx - tipX) < halfWidth + pw / 3) return true;
            }
            return false;
        }
        
        if (obj.type === 'double_spike') {
            var cx = px + pw / 2;
            var cy = py + ph / 2;
            
            for (var s = 0; s < 2; s++) {
                var tipX = obj.x + obj.w / 4 + s * obj.w / 2;
                var tipY = obj.y;
                var baseY = obj.y + obj.h;
                
                if (cy > tipY && cy < baseY) {
                    var ratio = (cy - tipY) / obj.h;
                    var halfWidth = (obj.w / 4) * ratio;
                    if (Math.abs(cx - tipX) < halfWidth + pw / 4) return true;
                }
            }
            return false;
        }
        
        return true;
    }
    
    // ============ RENDERING ============
    function render() {
        var w = canvas.width;
        var h = canvas.height;
        var groundY = h - CONFIG.GROUND_HEIGHT;
        var i;
        
        ctx.fillStyle = '#0a0a1a';
        ctx.fillRect(0, 0, w, h);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        var starOffset = (distance * 0.015) % w;
        for (i = 0; i < 25; i++) {
            var sx = ((i * 67 + 13) % w + w - starOffset) % w;
            var sy = (i * 41 + 17) % (groundY - 40);
            ctx.fillRect(sx, sy, 2, 2);
        }
        
        ctx.fillStyle = '#1a1a2e';
        ctx.fillRect(0, groundY, w, CONFIG.GROUND_HEIGHT);
        
        ctx.strokeStyle = '#00d4ff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(w, groundY);
        ctx.stroke();
        
        ctx.strokeStyle = 'rgba(0, 212, 255, 0.2)';
        ctx.lineWidth = 1;
        var gridOffset = (distance * 0.5) % 35;
        for (var gx = -gridOffset; gx < w; gx += 35) {
            ctx.beginPath();
            ctx.moveTo(gx, groundY);
            ctx.lineTo(gx, h);
            ctx.stroke();
        }
        for (var gy = groundY + 35; gy < h; gy += 35) {
            ctx.beginPath();
            ctx.moveTo(0, gy);
            ctx.lineTo(w, gy);
            ctx.stroke();
        }
        
        for (i = 0; i < portals.length; i++) {
            if (portals[i].active) drawPortal(portals[i], groundY);
        }
        
        for (i = 0; i < obstacles.length; i++) {
            if (obstacles[i].active) drawObstacle(obstacles[i]);
        }
        
        for (i = 0; i < particles.length; i++) {
            var p = particles[i];
            if (p.active) {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            }
        }
        ctx.globalAlpha = 1;
        
        if (gamePhase !== 'dead') {
            drawPlayer();
        }
        
        if (gamePhase === 'playing' && (player.mode === 'ship' || player.mode === 'wave')) {
            drawDirectionIndicator();
        }
    }
    
    function drawDirectionIndicator() {
        var indicatorX = player.x + CONFIG.PLAYER_SIZE + 10;
        var indicatorY = player.y + CONFIG.PLAYER_SIZE / 2;
        
        ctx.fillStyle = player.flyingUp ? '#00ff00' : '#ff6600';
        ctx.beginPath();
        
        if (player.flyingUp) {
            ctx.moveTo(indicatorX, indicatorY - 8);
            ctx.lineTo(indicatorX - 6, indicatorY + 4);
            ctx.lineTo(indicatorX + 6, indicatorY + 4);
        } else {
            ctx.moveTo(indicatorX, indicatorY + 8);
            ctx.lineTo(indicatorX - 6, indicatorY - 4);
            ctx.lineTo(indicatorX + 6, indicatorY - 4);
        }
        ctx.closePath();
        ctx.fill();
    }
    
    function drawPlayer() {
        var cx = player.x + CONFIG.PLAYER_SIZE / 2;
        var cy = player.y + CONFIG.PLAYER_SIZE / 2;
        var s = CONFIG.PLAYER_SIZE / 2;
        
        ctx.save();
        ctx.translate(cx, cy);
        
        if (player.mode === 'cube') {
            ctx.rotate(player.rotation * Math.PI / 180);
            ctx.fillStyle = '#00d4ff';
            ctx.fillRect(-s, -s, s * 2, s * 2);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(-s, -s, s * 2, s * 2);
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(s * 0.25, -s * 0.15, s * 0.32, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000000';
            ctx.beginPath();
            ctx.arc(s * 0.35, -s * 0.15, s * 0.16, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (player.mode === 'ship') {
            ctx.rotate(player.rotation * Math.PI / 180);
            ctx.fillStyle = '#e056fd';
            ctx.beginPath();
            ctx.moveTo(s, 0);
            ctx.lineTo(-s, -s * 0.75);
            ctx.lineTo(-s * 0.4, 0);
            ctx.lineTo(-s, s * 0.75);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            var thrustLen = player.flyingUp ? 1.4 : 1.1;
            ctx.fillStyle = player.flyingUp ? '#ffff00' : '#ff8800';
            ctx.beginPath();
            ctx.moveTo(-s * 0.4, -s * 0.25);
            ctx.lineTo(-s * thrustLen, 0);
            ctx.lineTo(-s * 0.4, s * 0.25);
            ctx.closePath();
            ctx.fill();
            
        } else if (player.mode === 'ufo') {
            ctx.fillStyle = '#00ff88';
            ctx.beginPath();
            ctx.arc(0, 0, s * 0.55, Math.PI, 0);
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#555555';
            ctx.beginPath();
            ctx.moveTo(-s, s * 0.15);
            ctx.quadraticCurveTo(0, s * 0.5, s, s * 0.15);
            ctx.quadraticCurveTo(0, s * 0.35, -s, s * 0.15);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(-s * 0.45, s * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(0, s * 0.25, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(s * 0.45, s * 0.2, 3, 0, Math.PI * 2);
            ctx.fill();
            
        } else if (player.mode === 'wave') {
            ctx.rotate(player.rotation * Math.PI / 180);
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.moveTo(s, 0);
            ctx.lineTo(0, -s * 0.55);
            ctx.lineTo(-s, 0);
            ctx.lineTo(0, s * 0.55);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
        
        ctx.restore();
    }
    
    function drawObstacle(obj) {
        ctx.save();
        
        if (obj.type === 'spike' || obj.type === 'tall_spike') {
            drawSpike(obj.x, obj.y, obj.w, obj.h);
        } else if (obj.type === 'double_spike') {
            drawSpike(obj.x, obj.y, obj.w / 2, obj.h);
            drawSpike(obj.x + obj.w / 2, obj.y, obj.w / 2, obj.h);
        } else if (obj.type === 'block') {
            ctx.fillStyle = '#ff9f43';
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
            ctx.beginPath();
            ctx.moveTo(obj.x + 6, obj.y + 6);
            ctx.lineTo(obj.x + obj.w - 6, obj.y + obj.h - 6);
            ctx.moveTo(obj.x + obj.w - 6, obj.y + 6);
            ctx.lineTo(obj.x + 6, obj.y + obj.h - 6);
            ctx.stroke();
        } else if (obj.type === 'saw') {
            ctx.translate(obj.x + obj.w / 2, obj.y + obj.h / 2);
            ctx.rotate(obj.rotation * Math.PI / 180);
            ctx.fillStyle = '#ee5a24';
            ctx.beginPath();
            var teeth = 8;
            var outerR = obj.w / 2;
            var innerR = obj.w / 3;
            for (var t = 0; t < teeth; t++) {
                var a1 = (t / teeth) * Math.PI * 2;
                var a2 = ((t + 0.5) / teeth) * Math.PI * 2;
                if (t === 0) ctx.moveTo(Math.cos(a1) * outerR, Math.sin(a1) * outerR);
                else ctx.lineTo(Math.cos(a1) * outerR, Math.sin(a1) * outerR);
                ctx.lineTo(Math.cos(a2) * innerR, Math.sin(a2) * innerR);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.fillStyle = '#333333';
            ctx.beginPath();
            ctx.arc(0, 0, innerR / 2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.restore();
    }
    
    function drawSpike(x, y, w, h) {
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x, y + h);
        ctx.lineTo(x + w, y + h);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.stroke();
    }
    
    function drawPortal(p, groundY) {
        var colors = { cube: '#00d4ff', ship: '#e056fd', ufo: '#00ff88', wave: '#f1c40f' };
        var color = colors[p.targetMode] || '#00d4ff';
        var portalTop = 5;
        var portalBottom = groundY - 5;
        
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.2;
        ctx.fillRect(p.x - 20, portalTop, 90, portalBottom - portalTop);
        ctx.globalAlpha = 1;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.moveTo(p.x + 20, portalTop);
        ctx.lineTo(p.x + 20, portalBottom);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.x + 30, portalTop);
        ctx.lineTo(p.x + 30, portalBottom);
        ctx.stroke();
        
        var pulse = Math.sin(p.animPhase) * 0.4 + 0.6;
        ctx.globalAlpha = pulse;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x + 25, portalTop + 10);
        ctx.lineTo(p.x + 25, portalBottom - 10);
        ctx.stroke();
        ctx.globalAlpha = 1;
        
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x + 15, portalTop);
        ctx.lineTo(p.x + 35, portalTop);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(p.x + 15, portalBottom);
        ctx.lineTo(p.x + 35, portalBottom);
        ctx.stroke();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(p.targetMode.toUpperCase(), p.x + 25, portalTop - 8);
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(p.x + 45, groundY / 2 - 15);
        ctx.lineTo(p.x + 55, groundY / 2);
        ctx.lineTo(p.x + 45, groundY / 2 + 15);
        ctx.closePath();
        ctx.fill();
    }
    
    // ============ GAME LOOP ============
    var lastTime = 0;
    
    function gameLoop(timestamp) {
        if (!timestamp) timestamp = 0;
        
        var dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        
        if (dt > 0.05) dt = 0.05;
        if (dt < 0) dt = 0;
        
        if (gamePhase === 'playing') {
            distance += CONFIG.GAME_SPEED * dt;
            score = Math.floor(distance / 10);
            scoreTextEl.innerHTML = score;
            
            if (distance > nextSpawnX - canvas.width - 100) {
                spawnObstacle();
                spawnPortal();
            }
            
            updatePlayer(dt);
            updateObstacles(dt);
            updatePortals(dt);
            updateParticles(dt);
        } else {
            updateParticles(dt);
        }
        
        inputJustPressed = false;
        render();
        requestAnimFrame(gameLoop);
    }
    
    // ============ INPUT HANDLERS ============
    function onInputDown(e) {
        if (e && e.preventDefault) e.preventDefault();
        inputJustPressed = true;
        return false;
    }
    
    if (canvas.addEventListener) {
        canvas.addEventListener('mousedown', onInputDown, false);
        canvas.addEventListener('touchstart', onInputDown, false);
    } else if (canvas.attachEvent) {
        canvas.attachEvent('onmousedown', onInputDown);
    }
    
    function attachClick(el, fn) {
        if (el.addEventListener) {
            el.addEventListener('click', fn, false);
            el.addEventListener('touchend', fn, false);
        } else if (el.attachEvent) {
            el.attachEvent('onclick', fn);
        }
    }
    
    attachClick(document.getElementById('btnPlay'), function(e) {
        if (e && e.preventDefault) e.preventDefault();
        resetGame();
        return false;
    });
    
    attachClick(document.getElementById('btnRetry'), function(e) {
        if (e && e.preventDefault) e.preventDefault();
        resetGame();
        return false;
    });
    
    if (document.addEventListener) {
        document.addEventListener('contextmenu', function(e) {
            if (e.preventDefault) e.preventDefault();
            return false;
        }, false);
    }
    
    // ============ START ============
    initPools();
    requestAnimFrame(gameLoop);
    
    </script>
</body>
</html>
